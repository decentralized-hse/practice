# Этап 3: Результаты сравнения операций работы с ветками

## 3.1. Операция: Просмотр веток (`git branch` vs `fossil branch list`)

### Методология сравнения производительности

Для справедливого сравнения производительности операций с ветками было проведено два теста:

1. **Сравнение на реальных данных**: Использовались оригинальные репозитории без изменений
   - Git: 6 основных веток
   - Fossil: 2975 веток (6 основных + ~2969 PR веток)

2. **Сравнение на очищенных данных**: Создана копия Fossil репозитория (`git-clean.fossil`), в которой все PR ветки были скрыты с помощью `fossil branch hide`
   - Git: 6 основных веток (без изменений)
   - Fossil: 6 основных веток видимы, ~148 PR веток скрыты (но все еще присутствуют в базе данных)

**Функциональность:**

**Git `branch`:**
- Показывает список локальных веток
- `-a` показывает все ветки (локальные и удаленные)
- `-v` показывает последний коммит на каждой ветке
- `-vv` показывает связь с удаленными ветками
- Ветка - это указатель на коммит

**Fossil `branch list`:**
- Показывает список всех веток в репозитории
- Ветка - это именованная последовательность коммитов
- Каждая ветка имеет имя и связана с коммитами через теги
- Показывает все ветки, включая созданные из pull requests

**Производительность:**

**Сравнение на реальных данных:**

| Операция | Git `branch -a` | Fossil `branch list` |
|----------|-----------------|---------------------|
| Просмотр всех веток | 0.014 сек | 0.162 сек |
| Количество веток | 6 веток | 2975 веток |

**Сравнение после скрытия PR веток:**

| Операция | Git `branch -a` | Fossil `branch list` (скрытые PR) |
|----------|-----------------|-----------------------------------|
| Просмотр всех веток | 0.014 сек | 0.127-0.236 сек |
| Количество видимых веток | 6 веток | 6 основных веток (+ 148 скрытых PR) |

**Наблюдения:**
- Git быстрее примерно в 11-12 раз на реальных данных (2975 веток в Fossil)
- Git быстрее примерно в 9-17 раз после скрытия PR веток (6 видимых веток в Fossil)
- Fossil показывает значительно больше веток (2975 vs 6 в Git) из-за импорта pull requests
- Разница объясняется моделью данных Fossil, которая создает ветки для pull requests и не может полностью удалить ветки с коммитами

**Особенности:**

**Git:**
- Легковесные ветки
- Можно быстро создавать и удалять ветки
- Ветки не хранят историю сами по себе
- Поддержка удаленных веток через `refs/remotes/`

**Fossil:**
- Именованные ветки с историей
- Каждый коммит принадлежит ветке
- Ветки создаются автоматически при коммитах
- Нет концепции "удаленных" веток (все ветки локальные)

**Выводы:**
- **Git** использует легковесную модель веток
- **Fossil** использует именованную модель веток
- **Производительность**: Git значительно быстрее для просмотра веток
- **Гибкость**: Git более гибкий для создания и управления ветками
- **Модель данных**: Разные подходы - Git использует указатели, Fossil использует теги веток

## 3.2. Pull Requests: различия между Git и Fossil

### Структура веток после импорта

**В Git репозитории:**
- 6 основных веток: `master`, `jch`, `maint`, `next`, `seen`, `todo`
- Pull Requests представлены как ветки (например, `refs/pull/10/head`, `refs/pull/100/merge`)

**В Fossil после импорта:**
- 6 основных веток: `master`, `jch`, `maint`, `next`, `seen`, `todo`, `amlog`
- ~2969 веток из Pull Requests в формате `<номер>/head` и `<номер>/merge`
- Всего: 2975 веток

При импорте из Git:
- Каждый PR создает минимум одну ветку (`<номер>/head`)
- Многие PR также создают ветку merge (`<номер>/merge`)
- Fossil сохраняет все ветки, которые были в Git, включая исторические PR

### Влияние на производительность

**Проблема сравнения:**
- Git показывает 6 веток (только основные)
- Fossil показывает 2975 веток (включая все PR)

**Это влияет на производительность:**
- `git branch -a` работает с 6 ветками → быстрее
- `fossil branch list` работает с 2975 ветками → медленнее

### Выводы

- При импорте все ветки Git (включая PR) становятся ветками Fossil
- Это приводит к большому количеству веток в Fossil и влияет на производительность операций с ветками

## 3.3. Операция: Создание веток (`git branch` vs `fossil branch new`)

**Функциональность:**

**Git `branch <name> [start-point]`:**
- Создает новую ветку как указатель на коммит
- Ветка - это легковесная структура
- Можно создать ветку на любом коммите: `git branch new-branch HEAD`, `git branch new-branch v2.0.0`, `git branch new-branch HEAD~5`
- Ветка создается без переключения на нее (для переключения используется `git switch` или `git checkout`)
- Можно создать ветку заранее, до начала работы над ней
- Синтаксис: `git branch <name> [start-point]` где `start-point` - коммит, ветка или тег

**Fossil `branch new <name> <basis>`:**
- Создает новую ветку от указанного коммита (basis)
- Ветка создается как тег, помечающий коммиты как принадлежащие к ветке
- Требует указания базового коммита (basis): `fossil branch new new-branch trunk`
- Синтаксис: `fossil branch new <name> <basis>` где `basis` - коммит или ветка

**Производительность:**

| Операция | Git `branch <name>` | Fossil `branch new <name> <basis>` |
|----------|---------------------|-------------------------------------|
| Создание ветки | 0.009 сек | 0.007 сек |

**Наблюдения:**
- Обе команды выполняются очень быстро
- Git создает легковесный указатель (файл в `.git/refs/heads/`)
- Fossil создает тег в базе данных SQLite
- Производительность сопоставима для простых операций

**Выводы:**
- **Git** позволяет создавать ветки заранее, до начала работы
- **Fossil** рекомендует создавать ветки при коммите, что более естественно для его модели данных
- **Гибкость**: Git более гибкий - можно создать ветку на любом коммите в любой момент
- **Модель данных**: Разные подходы отражают различия в архитектуре - Git использует указатели, Fossil использует теги веток

## 3.4. Операция: Удаление веток (`git branch -d` vs `fossil branch close` / `fossil branch hide`)

**Функциональность:**

**Git `branch -d` / `branch -D`:**
- `-d` (delete): Удаляет ветку, если она полностью слита в текущую ветку
- `-D` (force delete): Принудительно удаляет ветку независимо от статуса слияния
- Удаляет только указатель на коммит (файл в `.git/refs/heads/`)
- Коммиты остаются в репозитории и могут быть восстановлены по SHA-1 хешу
- Можно удалить несколько веток за раз: `git branch -d branch1 branch2 branch3`

**Fossil `branch close` / `branch hide`:**
- `fossil branch close`: Добавляет тег "closed" к ветке, помечая ее как закрытую
- `fossil branch hide`: Добавляет тег "hidden" к ветке, скрывая ее из списка
- Ветки с коммитами нельзя полностью удалить в Fossil
- Скрытые/закрытые ветки все ещё обрабатываются при выполнении операций

**Различия в подходе:**

**Git:**
- Ветка полностью удаляется из репозитория
- Указатель удаляется, но коммиты остаются доступными по SHA-1
- Можно восстановить удаленную ветку, если известен SHA-1 последнего коммита
- Удаление ветки не влияет на производительность - указатель просто удаляется

**Fossil:**
- Ветка не может быть удалена, если она содержит коммиты
- Можно только пометить ветку как закрытую или скрытую
- Ветка и коммиты остаются в базе данных навсегда
- Скрытые ветки все ещё влияют на производительность операций

**Производительность:**

| Операция | Git `branch -d` | Fossil `branch close` |
|----------|-----------------|----------------------|
| Удаление/закрытие ветки | 0.001 сек | 0.001-0.002 сек |

**Наблюдения:**
- Обе команды выполняются очень быстро
- Git удаляет указатель, Fossil добавляет тег
- В Fossil закрытые/скрытые ветки все еще обрабатываются при операциях (влияют на производительность)
- В Git удаленные ветки не влияют на производительность

**Выводы:**
- **Git**: Ветки можно полностью удалить, что очищает репозиторий от ненужных указателей
- **Fossil**: Ветки нельзя удалить - можно только закрыть или скрыть, что сохраняет историю, но может влиять на производительность

## 3.5. Операция: Слияние веток (`git merge` vs `fossil merge`)

**Функциональность:**

**Git `merge <branch>`:**
- Объединяет изменения из указанной ветки в текущую ветку
- Автоматически находит общий предок (merge base) двух веток
- Создает merge-коммит с двумя родителями (если не fast-forward)
- Fast-forward merge: если текущая ветка является прямым предком сливаемой ветки, просто перемещает указатель
- Трехстороннее слияние: использует общий предок, текущую ветку и сливаемую ветку
- Автоматически коммитит результат слияния (если нет конфликтов)
- При конфликтах останавливается и требует ручного разрешения

**Fossil `merge <version>`:**
- Объединяет изменения из указанной версии (коммита или ветки) в текущий checkout
- Находит ближайшего общего предка автоматически
- После merge нужно выполнить `fossil commit` для фиксации результата
- Поддерживает cherry-pick merge (слияние одного коммита)
- Поддерживает backout merge (откат изменений коммита)

**Различия в подходе:**

**Git:**
- Merge и commit объединены в одну операцию
- Автоматически создает merge-коммит (если не fast-forward)
- Fast-forward merge не создает merge-коммит, просто перемещает указатель
- Можно отменить merge до коммита: `git merge --abort`

**Fossil:**
- Merge и commit разделены на две операции
- Сначала `fossil merge` применяет изменения к рабочей директории
- Затем `fossil commit` фиксирует результат
- Можно отменить merge до коммита: `fossil undo`
- Всегда создает merge-коммит (нет концепции fast-forward)

**Обработка конфликтов:**

**Git:**
- При конфликтах помечает файлы как конфликтные
- Добавляет маркеры конфликта в файлы:
  ```
  <<<<<<< HEAD
  текущие изменения
  =======
  изменения из сливаемой ветки
  >>>>>>> branch-name
  ```
- Требует ручного разрешения конфликтов
- После разрешения нужно добавить файлы и завершить merge: `git add` и `git commit`

**Fossil:**
- При конфликтах помечает файлы как конфликтные
- Добавляет маркеры конфликта в файлы (аналогично Git)
- Показывает предупреждение: `WARNING: N merge conflicts`
- Требует ручного разрешения конфликтов
- После разрешения нужно зафиксировать: `fossil commit`

**Выводы:**
- **Git**: Merge и commit объединены, автоматически создает merge-коммит
- **Fossil**: Merge и commit разделены, требует явного коммита после merge
- **Гибкость**: Git поддерживает fast-forward merge, Fossil всегда создает merge-коммит
- **Конфликты**: Обе системы используют маркеры конфликтов, но Fossil предоставляет больше контекста и предложений по разрешению
