#!/bin/python3

import fcntl
import os
import subprocess
import sys

import paramiko

VERBOSE = True

def acquire_remote_lock(ssh):
    command = "exec {fd}>lock.lock; flock -x $fd; echo $fd"
    try:
        _, stdout, stderr = ssh.exec_command(command)
        output = stdout.read().decode().strip()
        error = stderr.read().decode().strip()
        if VERBOSE and error:
            print(f"Command {command} got following errors: {error}")
        return output.strip()
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)

def release_remote_lock(ssh, fd):
    command = f"exec {fd}>&-"
    try:
        _, stdout, stderr = ssh.exec_command(command)
        output = stdout.read().decode().strip()
        error = stderr.read().decode().strip()
        if VERBOSE and error:
            print(f"Command {command} got following errors: {error}")
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)

def diff_two_lists(x, y):
    x_set, y_set = set(x), set(y)
    only_x = list(x_set - y_set)
    only_y = list(y_set - x_set)
    return only_x, only_y

def get_remote_brik_files_names(ssh):
    command = "ls .rdx/brix"
    try:
        _, stdout, stderr = ssh.exec_command(command)
        output = stdout.read().decode().strip()
        error = stderr.read().decode().strip()
        if VERBOSE and error:
            print(f"Command {command} got following errors: {error}")
        return output.split("\n")
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)

def get_local_brik_files_names():
    return os.listdir(".rdx/brix")


def merge_remote_brik_files(ssh, files):
    if len(files) == 0:
        return None

    command = "./brix"
    for i, brik_file in enumerate(files):
        command += f" add {brik_file[:10]}"
        if i + 1 < len(brik_file):
            command += ','
    command += " merge"

    try:
        _, stdout, stderr = ssh.exec_command(command)
        output = stdout.read().decode().strip()
        error = stderr.read().decode().strip()
        if VERBOSE and error:
            print(f"Command {command} got following errors: {error}")
        return output.strip()
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)


def clear_remote_brik_files(ssh, files):
    if len(files) == 0:
        return

    command = "rm"
    for brik_file in files:
        command += f" .rdx/brix/{brik_file}"

    try:
        _, _, stderr = ssh.exec_command(command)
        error = stderr.read().decode().strip()
        if VERBOSE and error:
            print(f"Command {command} got following errors: {error}")
        return
    except Exception as e:
        print(f"Command failed with error: {e}")
        return


def fetch_remote_brik_file(ssh, brik_file_hash):
    try:
        sftp = ssh.open_sftp()
        filename = f".rdx/brix/{brik_file_hash}.brik"
        sftp.get(filename, filename)
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)
    finally:
        sftp.close()


def merge_local_brik_files(files):
    if len(files) == 0:
        return

    command = ["./brix"]
    for file in files:
        command.append(f" add {file[:10]},")
    command.append("merge")

    result = subprocess.run(
        command,
        capture_output=True,
        text=True,
        check=True,
    )

    for file in files:
        os.remove(f".rdx/brix/{file}")

    return result.stdout.strip()


def send_brik_file_to_remote(ssh, brik_file_hash):
    try:
        sftp = ssh.open_sftp()
        filename = f".rdx/brix/{brik_file_hash}.brik"
        sftp.put(filename, filename)
    except Exception as e:
        print(f"Command failed with error: {e}")
        ssh.close()
        sys.exit(1)
    finally:
        sftp.close()


def run_sync(host, port, username, password):
    print("Acquiring local lock...")
    local_lock_file = open("lock.lock", "w")
    fcntl.flock(local_lock_file, fcntl.LOCK_EX)

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        ssh.connect(host, port, username, password)
    except Exception as e:
        print(f"Connection failed with error: {e}")
        sys.exit(1)

    print("Acquiring remote lock...")
    remote_fd = acquire_remote_lock(ssh)

    remote_brik_files_names = get_remote_brik_files_names(ssh)
    local_brik_files = get_local_brik_files_names()
    only_local, only_remote = diff_two_lists(local_brik_files, remote_brik_files_names)

    merged_file_hash = merge_remote_brik_files(ssh, only_remote)
    clear_remote_brik_files(ssh, only_remote)

    list_to_merge = only_local
    if merged_file_hash is not None:
        fetch_remote_brik_file(ssh, merged_file_hash)
        clear_remote_brik_files(ssh, [f'{merged_file_hash}.brik'])
        list_to_merge.append(f'{merged_file_hash}.brik')

    if len(list_to_merge) > 0:
        local_merged_file_hash = merge_local_brik_files(list_to_merge)
        send_brik_file_to_remote(ssh, local_merged_file_hash)

    print("Releasing remote lock...")
    release_remote_lock(ssh, remote_fd)

    print("Syncing is over")
    ssh.close()

    print("Releasing local lock...")
    fcntl.flock(local_lock_file, fcntl.LOCK_UN)


if __name__ == "__main__":
    host = "127.0.0.1"
    port = 2222
    username = "testuser"
    password = "testpass"

    run_sync(host, port, username, password)
