# Сравнение rsync и git

## rsync

### Как rsync понимает, что файл изменился

Первое, что делает rsync, это обходит все файловое дерево на обеих сторонах. Просто рекурсивно проходит по директориям, собирает путь, размер и mtime каждого файла. Записывает эту информацию в два списка. Дальше он сравнивает эти списки. По умолчанию логика максимально простая: если у файла на отправителе и получателе совпадают размер и время модификации, rsync считает его неизмененным и ничего с ним не делает. Это называется quick check.

Это быстро, но ненадежно так как если файл поменяли и вручную поправили время изменения rsync не заметит. Если файловая система грубая (FAT32 хранит mtime с точностью до 2 секунд), и два изменения произошли в пределах одного кванта, rsync тоже не заметит или Если часы на двух машинах рассинхронились, тоже могут возникнуть проблемы.

Более надежный вариант флаг `--checksum`. Тогда rsync считает контрольную сумму (раньше MD5, сейчас в 3.2+ xxHash) всего файла целиком на обеих сторонах и сравнивает. Это гарантированно находит любое изменение, но файлы приходится читать целиком. На большом дереве это медленно.

Есть еще `--ignore-times`, который заставляет rsync считать все файлы измененными и передавать их все. Он эффективен за счет дельта-алгоритма который передаст только реальные различия.

### Дельта-алгоритм: как rsync передает минимум данных
Допустим, rsync решил, что файл надо обновить. Подход в лоб это отправить весь файл целиком, но rsync делает умнее.

Принимающая сторона берет свою (старую) версию файла, нарезает на чанки (размер подбирается автоматически, для мелких файлов это около 700 байт, для крупных больше). Для каждого такого блока считает две контрольные суммы. Первая, слабая, это вариация adler-32, 32 бита. Вторая, сильная, это MD5 или xxHash, 64-128 бит. Все эти пары сумм отправляются на сторону отправителя.

Отправитель берет свою версию файла и начинает скользить окном размером в один блок по всему файлу, побайтово. На каждой позиции он считает слабую контрольную сумму этого окна. Смысл использования слабой суммы в том, что она rolling: когда окно сдвигается на один байт, сумму можно пересчитать за O(1), не перечитывая весь блок заново(удалил старый байт, добавил новый и получил новую величину)

Если слабая сумма совпала с какой-то из сумм получателя (поиск по хеш-таблице, O(1)), отправитель считает для этого окна еще и сильную сумму. Если и она совпала, значит блок не изменился. В таком случае он просто сообщает номер блока и ничего не кидает если же значения не совпали то он кидает блок сырыми байтами.

Получатель собирает новый файл: берет свои старые блоки по номерам, вставляет между ними новые данные.

Почему две суммы, а не одна? Потому что слабая сумма быстро считается, но дает много ложных срабатываний (32 бита, коллизий много). Сильная сумма считается медленно, но почти гарантирует корректность. В итоге слабая сумма работает как фильтр: отсекает 99.9% позиций за дешево, а сильная проверяет только оставшиеся кандидаты.

## git

### Как git хранит файловое дерево

git не хранит диффы между версиями файлов, он хранит снапшоты. Каждый коммит это полное "описание" всего дерева на момент исполнения команды. 

Внутри git есть четыре типа объектов: blob, tree, commit, tag. Blob это содержимое файла целиком. Tree это описание одного уровня каталога, по сути список записей вида "имя файла, права, ссылка на blob или вложенный tree". Commit ссылается на корневой tree и на родительские коммиты. Tag это именованная ссылка на конкретный коммит. В отличие от веток, которые двигаются вперёд при новом коммите, тег всегда указывает на один и тот же коммит. Каждый объект идентифицируется SHA-1 хешем своего содержимого (с недавних пор есть поддержка SHA-256).

Eсли два файла в разных каталогах или в разных коммитах имеют одинаковое содержимое, они ссылаются на один и тот же blob. git не дублирует данные это называется content-addressable storage.

### Как git понимает, что изменилось

Когда нужно сравнить два состояния дерева (два коммита, коммит и рабочее дерево и т.д.), git сравнивает tree-объекты. И тут работает Merkle-Tree.

Он устроен так: хеш tree-объекта зависит от хешей всех вложенных blob и tree. Если в каталоге ничего не поменялось, его tree-хеш тоже не меняется. Если поменялся один файл в глубине дерева, меняются хеши всех tree-объектов по пути от этого файла до корня, а хеши всех остальных веток остаются как были.

Поэтому сравнение начинается с корневых tree. Если хеши совпали, все дерево идентично, делать нечего. Если не совпали, git спускается на один уровень ниже и сравнивает записи. Для каждой записи, чей хеш отличается, рекурсивно спускается дальше. Записи с совпавшими хешами пропускает целиком, не заглядывая внутрь.

В итоге сложность сравнения пропорциональна количеству различий, а не размеру дерева. В репозитории с миллионом файлов, где изменен один, git сравнит только несколько tree-объектов по пути к этому файлу.

### git status и index

При использовании команды git status, git сравнивает сразу три вещи: последний коммит (HEAD), index (staging area, файл `.git/index`) и рабочее дерево.

Index хранит для каждого отслеживаемого файла путь, SHA-1 содержимого и кучу stat-метаданных из файловой системы: ctime, mtime, inode, размер, device, uid, gid.

Логика такая: git берет файл на диске, делает системный вызов stat() и сравнивает результат с тем, что записано в index. Если mtime, размер, inode и остальное совпадает, git считает файл неизмененным и не вычисляет SHA-1 его содержимого. Это огромная экономия. В репозитории со 100 000 файлов, где изменен один, git прочитает содержимое только одного файла, а для остальных 99 999 сделает лишь stat().

Но тут есть подвох. Если файл изменили в ту же секунду, когда обновился index, mtime может совпасть и git не заметит изменение. Это проблема racily clean файлов. git знает про нее и в таких подозрительных случаях перечитывает содержимое и считает SHA-1 заново. То есть если mtime файла равен mtime самого index, git форсированно его проверяет.

### Переименования

git не хранит информацию о переименования. Когда ты делаешь git mv a.txt b.txt, он записывает удаление a.txt и создание b.txt с тем же содержимым.

Переименования определяются потом, при выводе diff. git видит что файл удален, и добавлен новый с таким же blob-хешом отсюда и понимает что это переименование. Если содержимое частично отличается, считается процент совпадения (по умолчанию порог 50%). Это эвристика и иногда может ошибиться.

### Packfiles и дельта-компрессия

При обычной работе каждый blob хранится как отдельный файл в .git/objects/. Это называется loose objects. Но когда объектов становится много, git запускает git gc и упаковывает их в packfile.

В packfile git ищет похожие объекты и хранит их как дельту от базового объекта. Причем не обязательно дельту от предыдущей версии того же файла. git может взять любой похожий blob как базу. Выбор базы основан на эвристике: файлы с похожим именем и размером, из последних коммитов.
Это критически важно для хранения и передачи по сети. При git push или git fetch данные передаются именно в формате packfile, и дельта-компрессия сильно уменьшает объем.

(Это не то же самое что сравнение блоков в rsync так как git работаем все же с целыми файлами и дельтами между ними)

### Дополнительные оптимизации

Untracked cache. git может кешировать информацию о файлах, которые он не отслеживает. Если mtime каталога не изменился, git не перечитывает его содержимое в поисках новых файлов.

Fsmonitor. Интеграция с демоном, который следит за файловой системой (watchman от Facebook или встроенный fsmonitor). Демон сообщает git, какие именно файлы изменились с прошлого раза. git проверяет только их, а не весь рабочий каталог. В монорепозиториях с сотнями тысяч файлов это сокращает git status с секунд до миллисекунд.

Split index. Для огромных репозиториев index разделяется на неизменяемую базу и дельту. Запись index ускоряется, потому что перезаписывается только дельта.

Sparse checkout. Можно материализовать на диске только часть файлов из репозитория. git status проверяет только то, что реально лежит на диске, а не весь репозиторий.

Commit graph. Отдельный файл с графом коммитов и generation numbers. Ускоряет обход истории: поиск общего предка, reachability queries и прочее. На сравнение деревьев напрямую не влияет, но ускоряет все, что связано с историей.

Bitmap index. Хранится рядом с packfile и позволяет за O(1) определить, какие объекты достижимы из данного коммита. Ускоряет git fetch и git clone, потому что серверу не нужно обходить граф для вычисления набора объектов.

## Сравнение

### Преимущество rsync
Во-первых, rsync умеет синхронизировать права, владельца, ACL, extended attributes(git этого не умеет, ему вроде это и не нужно, но в контексе сравнения следует упомянуть).

Во-вторых, rsync лучше справляется с передачей больших файлов с маленькими изменениями, так как у него есть бинарная дельто-компрессия.

### Преимущество git
Во-первых, rsync не понимает переименование, если изменить название файла, то rsync подумает, что старый был удален, а новый создан, что замедляет его работу. Есть флаг --fuzzy, который пытается решить эту проблему, но это эвристика, которая не всегда работает.

Во-вторых, rsync не хранит историю, каждый вызов по умолчанию выполняет всю работу с нуля, если не настроены backup'ы. Тут же возникает проблема с небольшими изменениями в дереве файлов, rsync придется проверить абсолютно все, даже если изменения минимальны.

В-третьих, git по умолчанию более корректен по сравнению с rsync, так как он полагается не только на name и mtime. 

